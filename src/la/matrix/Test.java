package la.matrix;

import ml.utils.*;
import la.decomposition.*;
import la.vector.*;
import la.vector.Vector;

import java.util.*;

public class Test
{
    public static void main(final String[] args) {
        final TreeMap<Integer, Integer> treeMap = new TreeMap<Integer, Integer>();
        treeMap.put(5, 0);
        treeMap.put(3, 1);
        treeMap.put(6, 2);
        treeMap.put(4, 3);
        System.out.printf("Key\tValue%n", new Object[0]);
        for (final Map.Entry<Integer, Integer> entry : treeMap.entrySet()) {
            System.out.printf("%d\t%d%n", entry.getKey(), entry.getValue());
        }
        System.out.println();
        final TreeMap<Pair<Integer, Integer>, Integer> map = new TreeMap<Pair<Integer, Integer>, Integer>();
        map.put(Pair.of(4, 0), 0);
        map.put(Pair.of(5, 0), 1);
        map.put(Pair.of(3, 1), 2);
        map.put(Pair.of(6, 2), 3);
        map.put(Pair.of(4, 3), 4);
        System.out.printf("RowIdx\tColIdx\tValIdx%n", new Object[0]);
        for (final Map.Entry<Pair<Integer, Integer>, Integer> entry2 : map.entrySet()) {
            System.out.printf("%d\t%d\t%d%n", entry2.getKey().first, entry2.getKey().second, entry2.getValue());
        }
        System.out.println();
        final int[] rIndices = { 0, 1, 3, 1, 2, 2, 3, 2, 3 };
        final int[] cIndices = { 0, 0, 0, 1, 1, 2, 2, 3, 3 };
        final double[] values = { 10.0, 3.2, 3.0, 9.0, 7.0, 8.0, 7.0, 7.0, 7.0 };
        final int numRows = 4;
        final int numColumns = 4;
        final int nzmax = rIndices.length;
        Matrix S = new SparseMatrix(rIndices, cIndices, values, numRows, numColumns, nzmax);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("det(S) = %.4f\n", Matlab.det(S));
        final LUDecomposition LUDecomp = new LUDecomposition(S);
        Printer.disp("L:");
        Printer.disp(LUDecomp.getL());
        Printer.disp("U:");
        Printer.disp(LUDecomp.getU());
        final Matrix invS = Matlab.inv(S);
        Printer.disp("inv(S):");
        Printer.disp(invS);
        Printer.disp("invS * S:");
        Printer.disp(invS.mtimes(S));
        Printer.fprintf("S':%n", new Object[0]);
        Printer.printMatrix(S.transpose(), 4);
        Printer.fprintf("S'':%n", new Object[0]);
        Printer.printMatrix(S.transpose().transpose(), 4);
        Printer.fprintf("S * S':%n", new Object[0]);
        Printer.printMatrix(S.mtimes(S.transpose()), 4);
        Printer.fprintf("S' * S:%n", new Object[0]);
        Printer.printMatrix(S.transpose().mtimes(S), 4);
        final double[][] data = { { 3.5, 4.4, 1.3, 2.3 }, { 5.3, 2.2, 0.5, 4.5 }, { 0.2, 0.3, 4.1, -3.1 }, { -1.2, 0.4, 3.2, 1.6 } };
        final Matrix A = new DenseMatrix(data);
        Printer.fprintf("A:%n", new Object[0]);
        Printer.printMatrix(A, 4);
        Printer.fprintf("A':%n", new Object[0]);
        Printer.printMatrix(A.transpose(), 4);
        final Matrix B = A.mtimes(S);
        Printer.fprintf("A * S:%n", new Object[0]);
        Printer.printMatrix(B, 4);
        Printer.fprintf("S * A:%n", new Object[0]);
        Printer.printMatrix(S.mtimes(A), 4);
        if (S instanceof SparseMatrix) {
            final int[] ic = ((SparseMatrix)S).getIc();
            final int[] jr = ((SparseMatrix)S).getJr();
            final double[] pr = ((SparseMatrix)S).getPr();
            final int[] valCSRIndices = ((SparseMatrix)S).getValCSRIndices();
            final double[] pr_CSR = new double[pr.length];
            for (int k = 0; k < ((SparseMatrix)S).getNZMax(); ++k) {
                pr_CSR[k] = pr[valCSRIndices[k]];
            }
            final Matrix S_CSR = SparseMatrix.createSparseMatrixByCSRArrays(ic, jr, pr_CSR, S.getRowDimension(), S.getColumnDimension(), ((SparseMatrix)S).getNZMax());
            Printer.fprintf("S_CSC:%n", new Object[0]);
            Printer.printMatrix(S, 4);
            Printer.fprintf("S_CSR:%n", new Object[0]);
            Printer.printMatrix(S_CSR, 4);
        }
        final int[] rIndices2 = rIndices.clone();
        rIndices2[0] = -1;
        final Matrix A_copy = A.copy();
        final double[][] data2 = ((DenseMatrix)A_copy).getData().clone();
        data2[0][0] = -100.0;
        Printer.fprintf("A + S:%n", new Object[0]);
        Printer.printMatrix(A.plus(S), 4);
        Printer.fprintf("S + A:%n", new Object[0]);
        Printer.printMatrix(S.plus(A), 4);
        final Matrix S2 = S.mtimes(S.transpose());
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S * S':%n", new Object[0]);
        Printer.printMatrix(S2, 4);
        Printer.fprintf("S * S' + S:%n", new Object[0]);
        Printer.printMatrix(S2.plus(S), 4);
        Printer.fprintf("S - S * S':%n", new Object[0]);
        Printer.printMatrix(S.minus(S2), 4);
        Printer.fprintf("S .* S':%n", new Object[0]);
        Printer.printMatrix(S.times(S.transpose()), 4);
        Printer.fprintf("S' .* S:%n", new Object[0]);
        Printer.printMatrix(S.transpose().times(S), 4);
        Vector V = new DenseVector(new double[] { 0.0, 1.0, 0.0, 3.0 });
        Printer.fprintf("S * V:%n", new Object[0]);
        Printer.printVector(S.operate(V));
        V = Matlab.sparse(V);
        Printer.fprintf("S * V:%n", new Object[0]);
        Printer.printVector(S.operate(V));
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.disp(S, 4);
        int r = -1;
        int c = -1;
        double v = 0.0;
        r = 3;
        c = 1;
        v = 1.5;
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        Printer.fprintf("S(%d, %d) <- %.2f%n", r + 1, c + 1, v);
        S.setEntry(r, c, v);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.disp(S);
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        r = 0;
        c = 2;
        v = 2.5;
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        Printer.fprintf("S(%d, %d) <- %.2f%n", r + 1, c + 1, v);
        S.setEntry(r, c, v);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.disp(S);
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        v = 0.0;
        Printer.fprintf("Delete S(%d, %d)%n", r + 1, c + 1);
        Printer.fprintf("S(%d, %d) <- %.2f%n", r + 1, c + 1, v);
        S.setEntry(r, c, v);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        r = 3;
        c = 1;
        v = 0.0;
        Printer.fprintf("Delete S(%d, %d)%n", r + 1, c + 1);
        Printer.fprintf("S(%d, %d) <- %.2f%n", r + 1, c + 1, v);
        S.setEntry(r, c, v);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        r = 3;
        c = 1;
        v = 1.5;
        Printer.fprintf("Add S(%d, %d) = %.2f%n", r + 1, c + 1, v);
        Printer.fprintf("S(%d, %d) <- %.2f%n", r + 1, c + 1, v);
        S.setEntry(r, c, v);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S, 4);
        Printer.fprintf("S(%d, %d) = %.2f%n", r + 1, c + 1, S.getEntry(r, c));
        final Matrix S3 = S.copy();
        final int M = 5;
        final int N = 5;
        S = new SparseMatrix(M, N);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.disp(S);
        S.setEntry(0, 3, 0.9);
        S.setEntry(0, 1, 0.8);
        S.setEntry(0, 1, 3.2);
        S.setEntry(0, 3, 0.6);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.disp(S);
        S = S3;
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S);
        Printer.fprintf("S:%n", new Object[0]);
        Printer.disp(S);
        Vector[] Vs = null;
        Vs = Matlab.sparseMatrix2SparseRowVectors(S);
        for (int i = 0; i < Vs.length; ++i) {
            Printer.fprintf("Vs[%d]:%n", i);
            Printer.disp(Vs[i]);
        }
        Printer.printMatrix(Matlab.sparseRowVectors2SparseMatrix(Vs));
        Printer.disp(Matlab.sparseRowVectors2SparseMatrix(Vs));
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S);
        Vs = Matlab.sparseMatrix2SparseColumnVectors(S);
        for (int i = 0; i < Vs.length; ++i) {
            Printer.fprintf("Vs[%d]:%n", i);
            Printer.disp(Vs[i]);
        }
        Printer.printMatrix(Matlab.sparseColumnVectors2SparseMatrix(Vs));
        Printer.disp(Matlab.sparseColumnVectors2SparseMatrix(Vs));
        Printer.fprintf("S:%n", new Object[0]);
        Printer.printMatrix(S);
        ((SparseMatrix)S).appendAnEmptyRow();
        Printer.fprintf("Append an empty row to S:%n", new Object[0]);
        Printer.printMatrix(Matlab.full(S));
        ((SparseMatrix)S).appendAnEmptyColumn();
        Printer.fprintf("Append an empty column to S:%n", new Object[0]);
        Printer.printMatrix(Matlab.full(S));
        Printer.disp(Matlab.hilb(5, 5));
        Printer.printMatrix(Matlab.hilb(5, 5).times(S));
    }
}
